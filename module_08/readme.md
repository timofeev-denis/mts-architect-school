# Практическое задание 08

## Цель

Применение паттерна сетевого взаимодействия Circuit Breaker.

## Описание

Облачные приложения - это распределённые системы, состоящие из большого количества отдельных компонентов, взаимодействующих по сети. Возможны случаи кратковременной или долговременной недоступности отдельных компонентов, и при этом система в целом должна продолжать работать. Для обработки долговременной недоступности отдельных компонентов приложения или внешних систем используется механизм Circuit Breaker (Автоматическое Выключение).

Задание строится на основе задания Module 04. Нужно обеспечить автоматическое отключение от сервиса Authors в случае его недоступности, и вместо данных автора возвращать какие-то значения по умолчанию.

## Форма отчетности

Работы публикуются в репозитории студента на Github.com.

## Установка зависимостей 
* Устанавливаем docker. https://docs.docker.com/desktop/install/windows-install/
* Устанавливаем питон pip - pip install "uvicorn[standard]"
* Устанавливаем фреймворк для запуска сервисов fastapi - pip install fastapi
* Устанавливаем дополнения - pip install requests
* Устанавливаем дополнения - pip install uvicorn
* Устанавливаем дополнения - pip install pyyaml
* Обновляем питон - python.exe -m pip install --upgrade pip


## Запуск проекта

Исходники проекта module_08 в репозитории https://github.com/MobileTeleSystems/arch-com.git 

### Запуск сервисов без сборки, для быстрого локального дебага
cd arch-school/basic/module_08/service_author;       uvicorn service_author:app       --reload --port 8081
cd arch-school/basic/module_08/service_presentation; uvicorn service_presentation:app --reload --port 8082
cd arch-school/basic/module_08/service_main;         uvicorn service_main:app         --reload --port 8083


### Сборка и запуск сервисов с docker-compose
docker-compose build && docker-compose up -d


## Работа с сервисами

### Вызов сервиса презентаций:
curl http://127.0.0.1:8082/presentations/Second%20Presentation

### Вызов сервиса авторов:
curl http://127.0.0.1:8081/authors/1

### Вызов интеграционного сервиса:
curl http://127.0.0.1:8083/presentationsAndAuthor/First%20Presentation


## Инструкция по доработке

Обе части информации (презентация + автор) в module_04 получаются единым методом "read_presentation".
В этом методе вызываются 2 разных внешних сервиса, доступность которых не гарантирована.
Если сервис с презентациями недоступен, то информации для возврата пользователю нет совсем.
Если сервис с авторами доступен, но недоступен сервис с авторами, то часть данных есть.
Реализуем такую логику - в случае недоступности сервиса с авторами, мы возвращаем информацию о презентации.
В полях с информацией об авторе возвращаем "temporary unavailable".

1. Разносим логику "read_presentation" на 2 части, "request_presentation" и "request_author".
2. Добавляем Circuit Breaker к "request_author".
3. Запускаем, проверяем работоспособность "presentationsAndAuthor".
4. Останавливаем контейнер "serviceAuthor".
5. Вызываем "presentationsAndAuthor" - приложение "подвисает" на попытке коннекта и retry. При этом вызывающая система ждёт ответа, а пользователь получает ухудшение опыта.
6. Продолжаем вызывать "presentationsAndAuthor" и отслеживаем размыкание Выключателя (open).
7. После размыкания Выключателя, ответы начинают возвращаться мнгновенно.
8. Ждём полуоткрытия Выключателя (half-open).
9. Вызываем "presentationsAndAuthor" - Выключатель снова размыкается.
10. Ответы по-прежнему возвращаются мнгновенно.
11. Включаем сервис "serviceAuthor".
12. Вызываем presentationsAndAuthor, отслеживаем что после полуоткрытия выключателя работоспособность восстанавливается, выключатель замыкается (closed).


## Задание
1. Запустите сервисы в контейнерах с docker-compose. Откройте логи сервиса presentationsAndAuthor.
2. Проверьте работоспособность системы и статус Выключателя.
3. Останавливая сервис "serviceAuthor", смоделируйте:
   1. Размыкание выключателя
   2. Полуоткрытие и размыкание
   3. Полуоткрытие и замыкание
Обратите внимание на задержки обработки вызовов до срабатывания Выключателя.
Сохраните логи с последовательностью closed -> open -> half-open -> closed -> half-open -> open и пришлите для проверки.

## Задание со звёздочкой
Попробуйте реализовать Circuit Breaker сами внутри сервиса "presentationsAndAuthor" (service_main), не импортируя circuitbreaker.py (при желании код можно копировать).

## Некоторые метавыводы
1. Обратите внимание как разделение "монолитной" функции "read_presentation" на независимые функции "get_presentation" и "get_author" позволило снизить связность как между сервисами, так и между соответствующими "бизнес-функциями".
2. Оцените для себя объём кода "чисто бизнес-логики для успешного сценария" и объём "вспомогательного" кода обработки ошибок (включая собственно объём кода circuitbreaker.py). Современные облачные платформы и фреймворки помогают сосредоточиться на бизнес-логике, отсюда сокращение T2M.
3. Используйте развитые фреймворки, платформы, управляемые сервисы, изучайте паттерны.
4. Выбирая технологии, опирайтесь на ТехРадар(ы). Непроверенные технологии несут риски, но есть огромная масса технологий/продуктов которые для вас тестируются всем миром.
5. Интеграционный сервис из задания можно запускать вообще без менеджмента сервисов/контейнеров, используя Serverless/FaaS.
